
# benchmarking

Benchmarking various implementations of readers-writer locks, `std::sync::RwLock`, `parking_lot::RwLock`, `tokio::sync::RwLock`.

```
cargo criterion --message-format=json > tmp/benchmark.json
```

We compare several different Rust implementations of readers-writer locks.

 - [pflock](https://crates.io/crates/pflock), based on "Reader-writer synchronization for shared-memory multiprocessor real-time systems"
 - [pairlock](https://crates.io/crates/pairlock)
 - [tokio](https://tokio.rs/)
 - [sharedmutex](https://crates.io/crates/shared-mutex)
 - [widerwlock](https://crates.io/crates/widerwlock)
 - [spin](https://crates.io/crates/spin)
 - [std::sync::RwLock](https://doc.rust-lang.org/std/sync/struct.RwLock.html)
 - [crossbeam::ShardedLock](https://docs.rs/crate/crossbeam/)

# LLVM Sanitizer

For Linux targets it is also possible to run the LLVM address sanitizer to detect memory issues in unsafe and C++ code. This requires the nightly version of the rust compiler, which can acquired using `rustup toolchain install nightly`. To show the symbols for the resulting stacktrace it is also convenient to install `llvm-symbolizer`, for example using `sudo apt install llvm` on Ubuntu. Afterwards, the tests can be executed with the address sanitizer enabled using `cargo +nightly xtask address-sanitizer`. Similarly, we
can also the thread sanitizer to detect data races using `cargo +nightly xtask thread-sanitizer`.

# Code Coverage

Code coverage can be automatically generated for the full workspace using a cargo task. The code coverage itself is generated by LLVM with source code instrumentation, which requires the preview tools to be installed `rustup component add llvm-tools-preview`, and [grcov](https://github.com/mozilla/grcov), which can be acquired using `cargo install grcov`. To execute the code coverage task use `cargo xtask coverage`. The resulting HTML code coverage report can be found in `target/coverage`. 

# Concurrency testing

Using the crate `loom` it is actually possible to test all possible
interleavings defined by the C11 memory standard to show that the shared mutex is data race free.
This can be used as follows:

```
RUSTFLAGS="--cfg loom" cargo test
```

If a violation is detected the following command can be used to show the exact trace and source code locations of read and write accesses.

```
LOOM_LOG=trace \
LOOM_LOCATION=1 \
LOOM_CHECKPOINT_INTERVAL=1 \
RUSTFLAGS="--cfg loom" \
cargo test --test <test_name> --release
```

# Related work

 - [1] BRAVO â€“ Biased Locking for Reader-Writer Locks https://www.usenix.org/system/files/atc19-dice.pdf
 - [2] NUMA-aware reader-writer locks https://dl.acm.org/doi/10.1145/2442516.2442532
 - [3] brlocks https://lwn.net/Articles/378911/
 - [4] Scalable reader-writer locks for parallel systems https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=222989
 - [5] Scalable read-mostly synchronization using passive reader-writerlocks https://www.usenix.org/conference/atc14/technical-sessions/presentation/liu
 - [6] Distributed Reader-Writer Mutex https://www.1024cores.net/home/lock-free-algorithms/reader-writer-problem/distributed-reader-writer-mutex
 - [7] Distributed Cache-Line Counter Scalable RW-Lock http://concurrencyfreaks.blogspot.com/2013/09/distributed-cache-line-counter-scalable.html
 - [8] Folly - https://github.com/facebook/folly